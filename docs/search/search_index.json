{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction The iOS Mobile SDK allows you to capture in-app referrals, and easily record any sales that occur on the back of these referrals within your iOS application. The SDK enables the following features within your iOS app: Click reference retrieval from inbound requests. Conversion creation with a range of attributes including custom metadata. Conversion item support for accurate shopping basket representation. Deep linking support for Web to App and App to App. These docs are specifically for version 2 of the SDK. If you're still using version 1.X, please find the legacy docs here . Most public methods use the Swift Result type and can return a PartnerizeError . Quick Start Installation CocoaPods Add the Partnerize pod into your Podfile and run pod install . target :YourTargetName do pod 'Partnerize', '~> 2.0' end Carthage Add github \"PerformanceHorizonGroup/partnerize-mobile-sdk-ios\" to your Cartfile. Run carthage update . Go to your Xcode project's \"General\" settings. Drag Partnerize.framework from Carthage/Build/iOS to the \"Embedded Binaries\" section. Make sure \u201cCopy items if needed\u201d is selected and click Finish. After verifying your project compiles, switch over to Build Phases and add a new Run Script build phase by clicking the + in the top left of the editor. Add the following command: /usr/local/bin/carthage copy-frameworks Click the + under Input Files and add an entry for Partnerize framework: $(SRCROOT)/Carthage/Build/iOS/Partnerize.framework This build phase isn\u2019t required for your project to run. However, it\u2019s a workaround for an App Store submission bug where apps with frameworks that contain binary images for the iOS simulator are automatically rejected. The carthage copy-frameworks command strips out these extra architectures. Manual Installation Download Partnerize for iOS and extract the zip. Go to your Xcode project's \"General\" settings. Drag Partnerize.xcframework to the \"Embedded Binaries\" section. Make sure \"Copy items if needed\" is selected and click Finish. For more information view this guide Handling inbound clicks When an inbound intent from a mobile web browser or iOS app launches your iOS app via a deep link, use the method handleInboundURL(url) . One synchronous, and one asynchronous. Which one you use is up to you but note the synchronous will block and therefore impact your app launch time. In addition, Partnerize will also store the clickRef received locally. This is then used later to post conversions. You can use the parameter persistClickRef in both examples to override the default behaviour, if you wish to store this clickRef yourself. Synchronous func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool { if let url = application.userActivity?.webpageURL, userActivity.activityType == NSUserActivityTypeBrowsingWeb { let result = Partnerize.handleInboundURL(url) switch result { case .success(let click): print(click) case .failure(let error): print(error) } } } Asynchronous Partnerize.handleInboundURL(url) { result in switch result { case .success(let click): print(click) case .failure(let error): print(error) } } Posting Conversions to Partnerize Once a conversion has been constructed and is ready to be recorded, it be can be sent to Partnerize using the following method let conversion = Conversion(conversionRef: \"conversionRef\") Partnerize.completeConversion(conversion) { result in switch result { case .success(let conversionResult): print(conversionResult.conversionId) case .failure(let error): print(error) } } Resources Click The Click class describes attributes and items within a click. This is returned from the method Partnerize.handleInboundURL(conversionUrl) . let clickRef: String = click.clickRef let camRef: String = click.camRef let destination: URL = click.destination let destinationMobile: URL? = click.destinationMobile let meta: [String:String] = click.meta let utmParams: [String:String] = click.utmParams Conversion The Conversion class describes attributes and items within a conversion. This is constructed then passed into the completeConversion method. let conversion = Conversion( conversionRef: \"conversionRef\", pubRef : \"pubRef\", adRef :\"adRef\", country : \"USA\", currency : \"USD\", custRef : \"custRef\", voucher : \"voucher\", tsource : \"Email\", tmetric : \"Booked\", customerType : .new, items: [ConversionItem(value: 10, category: \"Shoes\")], metadata : [\"hello\": \"world\"]) Clearing the Clickref It may be necessary to clear the click ref, this can be done with the following. Partnerize.clearClickref() TrafficSource The TrafficSource constants such as TrafficSource.affiliate are for used for setting the traffic source on a conversion. Raw strings can also be used however, the Partnerize platform only accepts a predefined list of traffic sources. CustomerType This enum can either be CustomerType.existing or CustomerType.new , and is used for setting the customer type on a conversion. ConversionMetric The ConversionMetric constants such as ConversionMetric.checkout are for use for setting the conversion metric on a conversion. Raw strings can also be used however, the Partnerize platform only accepts a predefined list of traffic sources. ConversionItem The ConversionItem class is a representation of an item within a Conversion to better represent a shopping basket. A ConversionItem requires a value and category for each item however additional attributes can be included; quantity , sku as well as custom metadata similar to conversions. let conversionItems = [ ConversionItem(value: 9.99, category: \"Tops\"), ConversionItem(value: 9.99, category: \"Tops\", quantity: 1), ConversionItem(value: 9.99, category: \"Shoes\", quantity: 3, sku: \"TRA-SPT-FIV\"), ] Development Mode During development of your iOS app you may need to debug the requests being made. This can be done by adding the following key/value to your conversion metadata. conversion.metadata = [\"development_mode\" : \"yes\"] Logging Logging may also be useful for debugging, this can help track errors when using the Partnerize SDK. This can be enabled like so. Partnerize.isLoggingEnabled = true In addition to this you can also inject a custom Logger implementation. This will help you understand what the SDK is doing and will help if any issues need raised. By default the Partnerize SDK will just print any logged messages. Below is an example of how to create and use your own PartnerizeLogger. class MyLogger: PartnerizeLogger { func log(_ message: String) { print(message) } } ... Partnerize.logger = MyLogger() Error Handling Any error coming back will be a Partnerize Error. This can be handle in the following manner: switch error { case .unknown: print(\"Something went really wrong\") case .invalidJsonPayload(missingKeys: let missingKeys): print(missingKeys) case .noClickRef: print(\"Missing clickRef\") case .invalidUrl: print(\"I passed in an invalid URL\") case .timeout: print(\"The request timed out, maybe try again\") } Configuration The Partnerize SDK exposes a way to configure timeouts for the various requests (in seconds). This is done with the Partnerize.configure(options) method. Any method that uses a completion handler will use the asyncTimeout parameter, whilst only Partnerize.handleInboundURL(url) will use syncTimeout . By default the values are: asyncTimeout: 10 syncTimeout: 1 let options = PartnerizeOptions(asyncTimeout: 30, syncTimeout: 20) Partnerize.configure(with: options) License Apache-2.0 Support If you encounter any issues please email support@partnerize.com with: Steps to reproduce Any URLs used Logger output The SDK Version embedded in your project Release Notes Release notes can be found here","title":2.0},{"location":"#introduction","text":"The iOS Mobile SDK allows you to capture in-app referrals, and easily record any sales that occur on the back of these referrals within your iOS application. The SDK enables the following features within your iOS app: Click reference retrieval from inbound requests. Conversion creation with a range of attributes including custom metadata. Conversion item support for accurate shopping basket representation. Deep linking support for Web to App and App to App. These docs are specifically for version 2 of the SDK. If you're still using version 1.X, please find the legacy docs here . Most public methods use the Swift Result type and can return a PartnerizeError .","title":"Introduction"},{"location":"#quick-start","text":"","title":"Quick Start"},{"location":"#installation","text":"","title":"Installation"},{"location":"#cocoapods","text":"Add the Partnerize pod into your Podfile and run pod install . target :YourTargetName do pod 'Partnerize', '~> 2.0' end","title":"CocoaPods"},{"location":"#carthage","text":"Add github \"PerformanceHorizonGroup/partnerize-mobile-sdk-ios\" to your Cartfile. Run carthage update . Go to your Xcode project's \"General\" settings. Drag Partnerize.framework from Carthage/Build/iOS to the \"Embedded Binaries\" section. Make sure \u201cCopy items if needed\u201d is selected and click Finish. After verifying your project compiles, switch over to Build Phases and add a new Run Script build phase by clicking the + in the top left of the editor. Add the following command: /usr/local/bin/carthage copy-frameworks Click the + under Input Files and add an entry for Partnerize framework: $(SRCROOT)/Carthage/Build/iOS/Partnerize.framework This build phase isn\u2019t required for your project to run. However, it\u2019s a workaround for an App Store submission bug where apps with frameworks that contain binary images for the iOS simulator are automatically rejected. The carthage copy-frameworks command strips out these extra architectures.","title":"Carthage"},{"location":"#manual-installation","text":"Download Partnerize for iOS and extract the zip. Go to your Xcode project's \"General\" settings. Drag Partnerize.xcframework to the \"Embedded Binaries\" section. Make sure \"Copy items if needed\" is selected and click Finish. For more information view this guide","title":"Manual Installation"},{"location":"#handling-inbound-clicks","text":"When an inbound intent from a mobile web browser or iOS app launches your iOS app via a deep link, use the method handleInboundURL(url) . One synchronous, and one asynchronous. Which one you use is up to you but note the synchronous will block and therefore impact your app launch time. In addition, Partnerize will also store the clickRef received locally. This is then used later to post conversions. You can use the parameter persistClickRef in both examples to override the default behaviour, if you wish to store this clickRef yourself.","title":"Handling inbound clicks"},{"location":"#synchronous","text":"func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool { if let url = application.userActivity?.webpageURL, userActivity.activityType == NSUserActivityTypeBrowsingWeb { let result = Partnerize.handleInboundURL(url) switch result { case .success(let click): print(click) case .failure(let error): print(error) } } }","title":"Synchronous"},{"location":"#asynchronous","text":"Partnerize.handleInboundURL(url) { result in switch result { case .success(let click): print(click) case .failure(let error): print(error) } }","title":"Asynchronous"},{"location":"#posting-conversions-to-partnerize","text":"Once a conversion has been constructed and is ready to be recorded, it be can be sent to Partnerize using the following method let conversion = Conversion(conversionRef: \"conversionRef\") Partnerize.completeConversion(conversion) { result in switch result { case .success(let conversionResult): print(conversionResult.conversionId) case .failure(let error): print(error) } }","title":"Posting Conversions to Partnerize"},{"location":"#resources","text":"","title":"Resources"},{"location":"#click","text":"The Click class describes attributes and items within a click. This is returned from the method Partnerize.handleInboundURL(conversionUrl) . let clickRef: String = click.clickRef let camRef: String = click.camRef let destination: URL = click.destination let destinationMobile: URL? = click.destinationMobile let meta: [String:String] = click.meta let utmParams: [String:String] = click.utmParams","title":"Click"},{"location":"#conversion","text":"The Conversion class describes attributes and items within a conversion. This is constructed then passed into the completeConversion method. let conversion = Conversion( conversionRef: \"conversionRef\", pubRef : \"pubRef\", adRef :\"adRef\", country : \"USA\", currency : \"USD\", custRef : \"custRef\", voucher : \"voucher\", tsource : \"Email\", tmetric : \"Booked\", customerType : .new, items: [ConversionItem(value: 10, category: \"Shoes\")], metadata : [\"hello\": \"world\"])","title":"Conversion"},{"location":"#clearing-the-clickref","text":"It may be necessary to clear the click ref, this can be done with the following. Partnerize.clearClickref()","title":"Clearing the Clickref"},{"location":"#trafficsource","text":"The TrafficSource constants such as TrafficSource.affiliate are for used for setting the traffic source on a conversion. Raw strings can also be used however, the Partnerize platform only accepts a predefined list of traffic sources.","title":"TrafficSource"},{"location":"#customertype","text":"This enum can either be CustomerType.existing or CustomerType.new , and is used for setting the customer type on a conversion.","title":"CustomerType"},{"location":"#conversionmetric","text":"The ConversionMetric constants such as ConversionMetric.checkout are for use for setting the conversion metric on a conversion. Raw strings can also be used however, the Partnerize platform only accepts a predefined list of traffic sources.","title":"ConversionMetric"},{"location":"#conversionitem","text":"The ConversionItem class is a representation of an item within a Conversion to better represent a shopping basket. A ConversionItem requires a value and category for each item however additional attributes can be included; quantity , sku as well as custom metadata similar to conversions. let conversionItems = [ ConversionItem(value: 9.99, category: \"Tops\"), ConversionItem(value: 9.99, category: \"Tops\", quantity: 1), ConversionItem(value: 9.99, category: \"Shoes\", quantity: 3, sku: \"TRA-SPT-FIV\"), ]","title":"ConversionItem"},{"location":"#development-mode","text":"During development of your iOS app you may need to debug the requests being made. This can be done by adding the following key/value to your conversion metadata. conversion.metadata = [\"development_mode\" : \"yes\"]","title":"Development Mode"},{"location":"#logging","text":"Logging may also be useful for debugging, this can help track errors when using the Partnerize SDK. This can be enabled like so. Partnerize.isLoggingEnabled = true In addition to this you can also inject a custom Logger implementation. This will help you understand what the SDK is doing and will help if any issues need raised. By default the Partnerize SDK will just print any logged messages. Below is an example of how to create and use your own PartnerizeLogger. class MyLogger: PartnerizeLogger { func log(_ message: String) { print(message) } } ... Partnerize.logger = MyLogger()","title":"Logging"},{"location":"#error-handling","text":"Any error coming back will be a Partnerize Error. This can be handle in the following manner: switch error { case .unknown: print(\"Something went really wrong\") case .invalidJsonPayload(missingKeys: let missingKeys): print(missingKeys) case .noClickRef: print(\"Missing clickRef\") case .invalidUrl: print(\"I passed in an invalid URL\") case .timeout: print(\"The request timed out, maybe try again\") }","title":"Error Handling"},{"location":"#configuration","text":"The Partnerize SDK exposes a way to configure timeouts for the various requests (in seconds). This is done with the Partnerize.configure(options) method. Any method that uses a completion handler will use the asyncTimeout parameter, whilst only Partnerize.handleInboundURL(url) will use syncTimeout . By default the values are: asyncTimeout: 10 syncTimeout: 1 let options = PartnerizeOptions(asyncTimeout: 30, syncTimeout: 20) Partnerize.configure(with: options)","title":"Configuration"},{"location":"#license","text":"Apache-2.0","title":"License"},{"location":"#support","text":"If you encounter any issues please email support@partnerize.com with: Steps to reproduce Any URLs used Logger output The SDK Version embedded in your project","title":"Support"},{"location":"#release-notes","text":"Release notes can be found here","title":"Release Notes"},{"location":"legacy/","text":"Introduction The iOS Mobile SDK allows you to capture in-app referrals, and easily record any sales that occur on the back of these referrals within your iOS application. It supports both Swift and Objective-C. The SDK provides two model classes; Conversion and ConversionItem . The Partnerize class is also used to provide functionality for dealing with inbound clicks, the combination of these classes enables the following features within your iOS app. Click reference retrieval from inbound requests. Conversion creation with a range of attributes including custom metadata. Conversion item support for accurate shopping basket representation. Deep linking support for Web to App and App to App. Quick Start Installation CocoaPods Add the Partnerize pod into your Podfile and run pod install . target :YourTargetName do pod 'Partnerize' end Carthage Add github \"PerformanceHorizonGroup/partnerize-mobile-sdk-ios\" to your Cartfile. Run carthage update . Go to your Xcode project's \"General\" settings. Drag Partnerize.framework from Carthage/Build/iOS to the \"Embedded Binaries\" section. Make sure \u201cCopy items if needed\u201d is selected and click Finish. After verifying your project compiles, switch over to Build Phases and add a new Run Script build phase by clicking the + in the top left of the editor. Add the following command: /usr/local/bin/carthage copy-frameworks Click the + under Input Files and add an entry for Partnerize framework: $(SRCROOT)/Carthage/Build/iOS/Partnerize.framework This build phase isn\u2019t required for your project to run. However, it\u2019s a workaround for an App Store submission bug where apps with frameworks that contain binary images for the iOS simulator are automatically rejected. The carthage copy-frameworks command strips out these extra architectures. Manual Installation Download Partnerize for iOS and extract the zip. Go to your Xcode project's \"General\" settings. Drag Partnerize.framework to the \"Embedded Binaries\" section. Make sure \"Copy items if needed\" is selected and click Finish. Create a new \u201cRun Script Phase\u201d in your app\u2019s target\u2019s \u201cBuild Phases\u201d and paste the following snippet in the script test field: bash \"${BUILT_PRODUCTS_DIR}/${FRAMEWORKS_FOLDER_PATH}/Partnerize.framework/strip-frameworks.sh\" Example app There is an example app provided here for Swift. Handling inbound clicks When an inbound intent from a mobile web browser or iOS app launches your iOS app via a deep link. This prepares an internal conversion object using Universal Link for further use and returns a new url containing original url with the app_clickref parameter stripped when conversion is completed. To return the full click object, use the following method. func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool { if userActivity.activityType == NSUserActivityTypeBrowsingWeb { let click = try? Partnerize.beginConversion(userActivity.webpageURL) let clickRef = click?.clickRef let camRef = click?.camRef let destination = click?.destination let utmParams = click?.utmParams let meta = click?.meta } } Alternatively, if just the destination URL is required, use the following method. func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool { if userActivity.activityType == NSUserActivityTypeBrowsingWeb { let url = try? Partnerize.beginConversion(with: userActivity.webpageURL) } Posting Conversions to Partnerize Once a conversion has been constructed and is ready to be recorded, it be can be sent to Partnerize using the following method. The completion block returns the status of the conversion and an error. Partnerize.completeConversion { isSuccess, error in if isSuccess { print(\"conversion logged\") } } Resources Click The Click class describes attributes and items within a click. This is returned from the method Partnerize.beginConversion(conversionUrl) . let clickRef = click?.clickRef let camRef = click?.camRef let destination = click?.destination let destinationMobile = click?.destinationMobile let utmParams = click?.utmParams let meta = click?.meta Conversion The Conversion class describes attributes and items within a conversion. This is accessed as a property on the Partnerize class. Partnerize.conversion?.adRef = \"myAddRef\" Partnerize.conversion?.pubRef = \"myPublisherRef\" Partnerize.conversion?.country = \"US\" Partnerize.conversion?.currency = \"USD\" Partnerize.conversion?.conversionRef = \"myConversionRef\" Partnerize.conversion?.custRef = \"myCustomerRef\" Partnerize.conversion?.voucher = \"25OFF\" Partnerize.conversion?.tsource = PHGAffiliateTrafficSource //\"Affiliate\" Partnerize.conversion?.customerType = .PHGNew Partnerize.conversion?.tmetric = PHGCheckoutConversionMetric // \"Checkout\" Partnerize.conversion?.metadata = [\"payment_type\" : \"crypto_currency\"] Partnerize.conversion?.items = [ConversionItem(value: \"11.99\", category: \"Shoes\", quantity: \"1\", sku: \"mySku\")] Clearing the Clickref It may be necessary to clear the click ref, this can be done with the following. Partnerize.conversion?.clearClickref() TrafficSource The PHGConversionTrafficSource constants such as PHGAffiliateTrafficSource are for used for setting the traffic source on a conversion. Raw strings can also be used however, the Partnerize platform only accepts a predefined list of traffic sources. CustomerType This enum can either be CustomerType.EXISTING or CustomerType.NEW , and is used for setting the customer type on a conversion. ConversionMetric The PHGConversionMetric constants such as PHGCheckoutConversionMetric are for use for setting the conversion metric on a conversion. Raw strings can also be used however, the Partnerize platform only accepts a predefined list of traffic sources. ConversionItem The ConversionItem class is a representation of an item within a Conversion to better represent a shopping basket. A ConversionItem requires a value and category for each item however additional attributes can be associated; quantity , sku as well as custom metadata similar to conversions. let conversionItems = [ ConversionItem(value: \"9.99\", category: \"Tops\"), ConversionItem(value: \"9.99\", category: \"Tops\", quantity: \"1\"), ConversionItem(value: \"9.99\", category: \"Shoes\", quantity: \"3\", sku: \"TRA-SPT-FIV\"), ] conversionItems.first?.metadata = [\"season\" : \"winter\"] Development Mode During development of your iOS app you may need to debug the requests being made. conversion.metadata = [\"development_mode\" : \"yes\"] Logging Logging may also be useful for debugging, this can help track errors when using the Partnerize SDK. This can be enabled like so. Partnerize.isLoggingEnabled = true License Apache-2.0 Release Notes Release notes can be found here","title":1.0},{"location":"legacy/#introduction","text":"The iOS Mobile SDK allows you to capture in-app referrals, and easily record any sales that occur on the back of these referrals within your iOS application. It supports both Swift and Objective-C. The SDK provides two model classes; Conversion and ConversionItem . The Partnerize class is also used to provide functionality for dealing with inbound clicks, the combination of these classes enables the following features within your iOS app. Click reference retrieval from inbound requests. Conversion creation with a range of attributes including custom metadata. Conversion item support for accurate shopping basket representation. Deep linking support for Web to App and App to App.","title":"Introduction"},{"location":"legacy/#quick-start","text":"","title":"Quick Start"},{"location":"legacy/#installation","text":"","title":"Installation"},{"location":"legacy/#cocoapods","text":"Add the Partnerize pod into your Podfile and run pod install . target :YourTargetName do pod 'Partnerize' end","title":"CocoaPods"},{"location":"legacy/#carthage","text":"Add github \"PerformanceHorizonGroup/partnerize-mobile-sdk-ios\" to your Cartfile. Run carthage update . Go to your Xcode project's \"General\" settings. Drag Partnerize.framework from Carthage/Build/iOS to the \"Embedded Binaries\" section. Make sure \u201cCopy items if needed\u201d is selected and click Finish. After verifying your project compiles, switch over to Build Phases and add a new Run Script build phase by clicking the + in the top left of the editor. Add the following command: /usr/local/bin/carthage copy-frameworks Click the + under Input Files and add an entry for Partnerize framework: $(SRCROOT)/Carthage/Build/iOS/Partnerize.framework This build phase isn\u2019t required for your project to run. However, it\u2019s a workaround for an App Store submission bug where apps with frameworks that contain binary images for the iOS simulator are automatically rejected. The carthage copy-frameworks command strips out these extra architectures.","title":"Carthage"},{"location":"legacy/#manual-installation","text":"Download Partnerize for iOS and extract the zip. Go to your Xcode project's \"General\" settings. Drag Partnerize.framework to the \"Embedded Binaries\" section. Make sure \"Copy items if needed\" is selected and click Finish. Create a new \u201cRun Script Phase\u201d in your app\u2019s target\u2019s \u201cBuild Phases\u201d and paste the following snippet in the script test field: bash \"${BUILT_PRODUCTS_DIR}/${FRAMEWORKS_FOLDER_PATH}/Partnerize.framework/strip-frameworks.sh\"","title":"Manual Installation"},{"location":"legacy/#example-app","text":"There is an example app provided here for Swift.","title":"Example app"},{"location":"legacy/#handling-inbound-clicks","text":"When an inbound intent from a mobile web browser or iOS app launches your iOS app via a deep link. This prepares an internal conversion object using Universal Link for further use and returns a new url containing original url with the app_clickref parameter stripped when conversion is completed. To return the full click object, use the following method. func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool { if userActivity.activityType == NSUserActivityTypeBrowsingWeb { let click = try? Partnerize.beginConversion(userActivity.webpageURL) let clickRef = click?.clickRef let camRef = click?.camRef let destination = click?.destination let utmParams = click?.utmParams let meta = click?.meta } } Alternatively, if just the destination URL is required, use the following method. func application(_ application: UIApplication, continue userActivity: NSUserActivity, restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void) -> Bool { if userActivity.activityType == NSUserActivityTypeBrowsingWeb { let url = try? Partnerize.beginConversion(with: userActivity.webpageURL) }","title":"Handling inbound clicks"},{"location":"legacy/#posting-conversions-to-partnerize","text":"Once a conversion has been constructed and is ready to be recorded, it be can be sent to Partnerize using the following method. The completion block returns the status of the conversion and an error. Partnerize.completeConversion { isSuccess, error in if isSuccess { print(\"conversion logged\") } }","title":"Posting Conversions to Partnerize"},{"location":"legacy/#resources","text":"","title":"Resources"},{"location":"legacy/#click","text":"The Click class describes attributes and items within a click. This is returned from the method Partnerize.beginConversion(conversionUrl) . let clickRef = click?.clickRef let camRef = click?.camRef let destination = click?.destination let destinationMobile = click?.destinationMobile let utmParams = click?.utmParams let meta = click?.meta","title":"Click"},{"location":"legacy/#conversion","text":"The Conversion class describes attributes and items within a conversion. This is accessed as a property on the Partnerize class. Partnerize.conversion?.adRef = \"myAddRef\" Partnerize.conversion?.pubRef = \"myPublisherRef\" Partnerize.conversion?.country = \"US\" Partnerize.conversion?.currency = \"USD\" Partnerize.conversion?.conversionRef = \"myConversionRef\" Partnerize.conversion?.custRef = \"myCustomerRef\" Partnerize.conversion?.voucher = \"25OFF\" Partnerize.conversion?.tsource = PHGAffiliateTrafficSource //\"Affiliate\" Partnerize.conversion?.customerType = .PHGNew Partnerize.conversion?.tmetric = PHGCheckoutConversionMetric // \"Checkout\" Partnerize.conversion?.metadata = [\"payment_type\" : \"crypto_currency\"] Partnerize.conversion?.items = [ConversionItem(value: \"11.99\", category: \"Shoes\", quantity: \"1\", sku: \"mySku\")]","title":"Conversion"},{"location":"legacy/#clearing-the-clickref","text":"It may be necessary to clear the click ref, this can be done with the following. Partnerize.conversion?.clearClickref()","title":"Clearing the Clickref"},{"location":"legacy/#trafficsource","text":"The PHGConversionTrafficSource constants such as PHGAffiliateTrafficSource are for used for setting the traffic source on a conversion. Raw strings can also be used however, the Partnerize platform only accepts a predefined list of traffic sources.","title":"TrafficSource"},{"location":"legacy/#customertype","text":"This enum can either be CustomerType.EXISTING or CustomerType.NEW , and is used for setting the customer type on a conversion.","title":"CustomerType"},{"location":"legacy/#conversionmetric","text":"The PHGConversionMetric constants such as PHGCheckoutConversionMetric are for use for setting the conversion metric on a conversion. Raw strings can also be used however, the Partnerize platform only accepts a predefined list of traffic sources.","title":"ConversionMetric"},{"location":"legacy/#conversionitem","text":"The ConversionItem class is a representation of an item within a Conversion to better represent a shopping basket. A ConversionItem requires a value and category for each item however additional attributes can be associated; quantity , sku as well as custom metadata similar to conversions. let conversionItems = [ ConversionItem(value: \"9.99\", category: \"Tops\"), ConversionItem(value: \"9.99\", category: \"Tops\", quantity: \"1\"), ConversionItem(value: \"9.99\", category: \"Shoes\", quantity: \"3\", sku: \"TRA-SPT-FIV\"), ] conversionItems.first?.metadata = [\"season\" : \"winter\"]","title":"ConversionItem"},{"location":"legacy/#development-mode","text":"During development of your iOS app you may need to debug the requests being made. conversion.metadata = [\"development_mode\" : \"yes\"]","title":"Development Mode"},{"location":"legacy/#logging","text":"Logging may also be useful for debugging, this can help track errors when using the Partnerize SDK. This can be enabled like so. Partnerize.isLoggingEnabled = true","title":"Logging"},{"location":"legacy/#license","text":"Apache-2.0","title":"License"},{"location":"legacy/#release-notes","text":"Release notes can be found here","title":"Release Notes"},{"location":"migration-2.0/","text":"Partnerize Mobile SDK Migration Guide Benefits of Migration Overhauled public API, it's not much clearer what the SDK does, including the errors that can be returned. Additional public methods such as isClickRequest and an async version of handleInboundURL have been added. Better logging with the ability to attach a custom Logger. Timeout configuration options. More features going forward. Breaking Changes Most methods now return a Swift Result type. beginConversion has been renamed to handleInboundURL . This method now takes additional parameters such as persistClickRef: Bool and an optional completion handler. beginConversion now returns a full Click object (wrapped in a swift Result ), rather than a just a destination URL, desinationUrl is accessible via click.destinationUrl . completeConversion now takes a Conversion object as it's first parameter, rather than updating a static conversion property on Partnerize . The completeConversion completion handler now only has one parameter Result<ConversionResult, PartnerizeError> , instead of the previous Bool and Error . There is no longer a static Partnerze.conversion instance, construct a Conversion object and pass into completeConversion .","title":"Migration Guide"},{"location":"migration-2.0/#partnerize-mobile-sdk-migration-guide","text":"","title":"Partnerize Mobile SDK Migration Guide"},{"location":"migration-2.0/#benefits-of-migration","text":"Overhauled public API, it's not much clearer what the SDK does, including the errors that can be returned. Additional public methods such as isClickRequest and an async version of handleInboundURL have been added. Better logging with the ability to attach a custom Logger. Timeout configuration options. More features going forward.","title":"Benefits of Migration"},{"location":"migration-2.0/#breaking-changes","text":"Most methods now return a Swift Result type. beginConversion has been renamed to handleInboundURL . This method now takes additional parameters such as persistClickRef: Bool and an optional completion handler. beginConversion now returns a full Click object (wrapped in a swift Result ), rather than a just a destination URL, desinationUrl is accessible via click.destinationUrl . completeConversion now takes a Conversion object as it's first parameter, rather than updating a static conversion property on Partnerize . The completeConversion completion handler now only has one parameter Result<ConversionResult, PartnerizeError> , instead of the previous Bool and Error . There is no longer a static Partnerze.conversion instance, construct a Conversion object and pass into completeConversion .","title":"Breaking Changes"}]}